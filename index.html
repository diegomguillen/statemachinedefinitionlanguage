<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Requisitos LDME v6.8</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .grab { cursor: grab; }
        .grabbing { cursor: grabbing; }
        #mermaid-output svg { min-width: 100%; min-height: 100%; }
        
        /* CodeMirror Customization */
        .CodeMirror {
            height: 100%;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
        }
        .cm-s-default .cm-comment { color: #9ca3af; }
        .cm-s-default .cm-keyword { color: #8C4D4D; } /* Main text color */
        .CodeMirror-hints {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            z-index: 20 !important;
        }
        .CodeMirror-readonly .CodeMirror-cursor {
            display: none !important;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 h-screen flex flex-col overflow-hidden">
    
    <!-- Startup Modal -->
    <div id="startup-modal" class="fixed inset-0 bg-gray-900 bg-opacity-60 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-8 max-w-md w-full text-center">
            <h2 class="text-2xl font-bold mb-4">Gestor de Requisitos LDME</h2>
            <p class="text-gray-600 mb-6">Carga un archivo `requisitos.json` existente o empieza un nuevo proyecto.</p>
            <div class="flex flex-col space-y-4">
                <button id="load-file-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cargar Archivo</button>
                <input type="file" id="file-input" class="hidden" accept=".json">
                <button id="new-project-btn" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg transition-colors">Crear Proyecto Nuevo</button>
            </div>
        </div>
    </div>

    <!-- Main Application (Hidden initially) -->
    <div id="app-container" class="h-full flex flex-col hidden">
        <!-- Header -->
        <header class="bg-white border-b border-gray-300 p-3 flex justify-between items-center shadow-sm">
            <div class="flex items-center space-x-4">
                <label for="requirement-selector" class="font-semibold text-sm">Requisito:</label>
                <select id="requirement-selector" class="text-sm bg-white border border-gray-300 rounded-md px-3 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500 min-w-[200px]"></select>
                <button id="add-req-btn" class="px-3 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-md transition-colors">+ Añadir</button>
            </div>
            <!--<h1 class="text-xl font-bold text-gray-900">Editor de Máquinas de Estado</h1>-->
            <button id="save-btn" class="px-4 py-2 text-sm bg-green-600 hover:bg-green-700 text-white font-bold rounded-md transition-colors">Guardar Proyecto</button>
        </header>

        <!-- Main Content -->
        <main id="main-container" class="flex flex-1 overflow-hidden">
            <!-- Left Pane -->
            <div id="left-pane" class="w-1/2 p-4 flex flex-col">
                <div id="editor-wrapper" class="flex-1 relative min-h-0"></div>
                <!-- Diagnostics Pane -->
                <div class="mt-4 flex-shrink-0">
                    <h3 class="font-semibold text-gray-700 mb-2">Diagnóstico del Proyecto</h3>
                    <div id="diagnostics-output" class="bg-white border border-gray-300 rounded-lg p-3 text-xs h-24 overflow-y-auto"></div>
                </div>
            </div>

            <!-- Resizer -->
            <div id="resizer" class="w-2 cursor-col-resize bg-gray-300 hover:bg-blue-500 transition-colors"></div>

            <!-- Right Pane -->
            <div id="right-pane" class="w-1/2 p-4 flex flex-col">
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center space-x-4">
                         <select id="diagram-type-selector" class="font-semibold text-gray-700 bg-transparent border-none focus:outline-none">
                            <option value="state">Diagrama de Estado</option>
                            <option value="dependency">Dependencia de Requisitos</option>
                         </select>
                        <select id="graph-direction" class="text-xs bg-white border border-gray-300 rounded-md px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500">
                            <option value="">Default</option>
                            <option value="LR">Izquierda-Derecha</option>
                            <option value="RL">Derecha-Izquierda</option>
                            <option value="BT">Abajo-Arriba</option>
                        </select>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="show-code-btn" class="px-3 py-1 text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-md transition-colors">Ver Código</button>
                        <button id="reset-view" class="px-3 py-1 text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-md transition-colors">Resetear Vista</button>
                        <button id="external-window-btn" class="px-3 py-1 text-xs bg-indigo-200 hover:bg-indigo-300 text-indigo-700 rounded-md transition-colors">Ventana Externa</button>
                    </div>
                </div>
                <div id="diagram-viewport" class="flex-1 bg-white border border-gray-300 rounded-lg overflow-hidden relative shadow-inner">
                    <div id="pan-zoom-wrapper" class="w-full h-full grab">
                        <div id="mermaid-output" class="w-full h-full flex items-center justify-center p-4"></div>
                    </div>
                     <div id="error-display" class="absolute top-0 left-0 w-full h-full bg-red-100 bg-opacity-90 text-red-700 p-4 font-mono text-sm hidden items-center justify-center overflow-auto"></div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Mermaid Code Modal -->
    <div id="code-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-1/2 max-w-4xl flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold">Código Mermaid Generado</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl font-bold">&times;</button>
            </div>
            <pre class="bg-gray-100 text-gray-800 p-4 rounded-md overflow-auto flex-1 text-sm"><code id="mermaid-code-output"></code></pre>
        </div>
    </div>
    
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/mode/simple.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- GLOBAL APP STATE ---
            let appState = {
                requirements: [],
                currentReqIndex: -1,
                vocabulary: { states: new Set(), actions: new Set(), objects: new Set(), sources: new Set(), events: new Set() }
            };
            let externalWindow = null;

            // --- DOM ELEMENTS ---
            const startupModal = document.getElementById('startup-modal');
            const appContainer = document.getElementById('app-container');
            const editorWrapper = document.getElementById('editor-wrapper');
            const mermaidOutput = document.getElementById('mermaid-output');
            const errorDisplay = document.getElementById('error-display');
            const directionSelector = document.getElementById('graph-direction');
            const diagramTypeSelector = document.getElementById('diagram-type-selector');
            const requirementSelector = document.getElementById('requirement-selector');
            const diagnosticsOutput = document.getElementById('diagnostics-output');
            const codeModal = document.getElementById('code-modal');
            const showCodeBtn = document.getElementById('show-code-btn');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const mermaidCodeOutput = document.getElementById('mermaid-code-output');
            const addReqBtn = document.getElementById('add-req-btn');
            const externalWindowBtn = document.getElementById('external-window-btn');

            // --- CODEMIRROR SETUP ---
            CodeMirror.defineSimpleMode("ldme", {
                start: [
                    { regex: /\/\/.*/, token: "comment" },
                    { regex: /⇒|\[|\]|\(|\)|\{|\}|@|!|\.|\,/, token: "operator" },
                    { regex: /[\w-]+/, token: "keyword" } 
                ]
            });

            const editor = CodeMirror(editorWrapper, {
                mode: 'ldme',
                lineNumbers: false,
                lineWrapping: true,
                extraKeys: {"Ctrl-Space": "autocomplete"}
            });
            
            // --- AUTOCOMPLETE SETUP ---
            CodeMirror.registerHelper('hint', 'ldme', (cm) => {
                const cursor = cm.getCursor();
                const token = cm.getTokenAt(cursor);
                const line = cm.getLine(cursor.line);
                
                let context = null;
                const lineBeforeCursor = line.substring(0, cursor.ch);

                if (lineBeforeCursor.lastIndexOf('[') > lineBeforeCursor.lastIndexOf(']')) { 
                    if (lineBeforeCursor.lastIndexOf('.') > lineBeforeCursor.lastIndexOf('[')) context = 'objects';
                    else context = 'actions';
                } else if (lineBeforeCursor.lastIndexOf('(') > lineBeforeCursor.lastIndexOf(')')) {
                     const partInParen = lineBeforeCursor.substring(lineBeforeCursor.lastIndexOf('('));
                     if(partInParen.includes('.')) context = 'events';
                     else context = 'sources';
                } else {
                    context = 'states';
                }

                const start = token.start;
                const end = cursor.ch;
                const currentWord = token.string.trim();

                const list = [...appState.vocabulary[context]]
                    .filter(item => item.toLowerCase().startsWith(currentWord.toLowerCase()))
                    .map(item => ({ text: item, displayText: item }));

                if (list.length > 0 && currentWord.length > 0) {
                    return { list: list, from: CodeMirror.Pos(cursor.line, start), to: CodeMirror.Pos(cursor.line, end) };
                }
            });


            // --- FILE MANAGEMENT ---
            const loadFileBtn = document.getElementById('load-file-btn');
            const fileInput = document.getElementById('file-input');
            const newProjectBtn = document.getElementById('new-project-btn');
            const saveBtn = document.getElementById('save-btn');

            loadFileBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (Array.isArray(data) && data.every(r => 'title' in r && 'content' in r)) {
                                initializeProject(data);
                            } else { alert('Error: El archivo JSON no tiene el formato esperado.'); }
                        } catch (err) { alert('Error al leer el archivo JSON.'); }
                    };
                    reader.readAsText(file);
                }
            });

            newProjectBtn.addEventListener('click', () => {
                const newReq = {
                    title: 'NUEVO REQUISITO',
                    content: `NUEVO REQUISITO
// Escribe aquí tus notaciones.
estado_inicial ⇒ [accion.objeto(evento)] ⇒ estado_final`
                };
                initializeProject([newReq]);
            });

            saveBtn.addEventListener('click', () => {
                updateCurrentRequirementContent();
                const dataToSave = appState.requirements;
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToSave, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "requisitos.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();

                saveBtn.textContent = '¡Guardado!';
                saveBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                saveBtn.classList.add('bg-green-500');
                setTimeout(() => {
                    saveBtn.textContent = 'Guardar Proyecto';
                    saveBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    saveBtn.classList.remove('bg-green-500');
                }, 2000);
            });
            
            function initializeProject(requirementsData) {
                appState.requirements = requirementsData;
                appState.currentReqIndex = -1; // Start with "ALL" view
                startupModal.classList.add('hidden');
                appContainer.classList.remove('hidden');
                appContainer.classList.add('flex');
                populateSelector();
                loadRequirementInEditor();
                editor.refresh();
            }

            // --- REQUIREMENT MANAGEMENT ---
            addReqBtn.addEventListener('click', () => {
                updateCurrentRequirementContent(); // Save current work if any
                const newReq = {
                    title: 'NUEVO REQUISITO SIN TÍTULO',
                    content: `NUEVO REQUISITO SIN TÍTULO
// Define aquí las reglas para el nuevo requisito.`
                };
                appState.requirements.push(newReq);
                appState.currentReqIndex = appState.requirements.length - 1;
                populateSelector();
                loadRequirementInEditor();
                editor.focus();
            });

            function populateSelector() {
                const currentVal = requirementSelector.value;
                requirementSelector.innerHTML = '';
                const allOption = document.createElement('option');
                allOption.value = -1;
                allOption.textContent = "TODOS";
                requirementSelector.appendChild(allOption);

                appState.requirements.forEach((req, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = req.title;
                    requirementSelector.appendChild(option);
                });
                requirementSelector.value = currentVal;
                 if(requirementSelector.value === '') {
                     requirementSelector.value = appState.currentReqIndex;
                 }
            }
            
            const handleSelectorChange = () => {
                updateCurrentRequirementContent();
                appState.currentReqIndex = parseInt(requirementSelector.value, 10);
                loadRequirementInEditor();
            };
            requirementSelector.addEventListener('change', handleSelectorChange);


            function loadRequirementInEditor() {
                let contentToShow = '';
                if (appState.currentReqIndex === -1) {
                    contentToShow = appState.requirements.map(req => req.content).join('\n\n// ---- FIN REQUISITO ----\n\n');
                } else if (appState.currentReqIndex > -1) {
                    contentToShow = appState.requirements[appState.currentReqIndex].content;
                }
                editor.setValue(contentToShow);
                editor.setOption("readOnly", false);
                // The 'change' event from setValue will trigger processing and rendering.
                // Call refresh to ensure layout is correct, especially for scrollbars.
                setTimeout(() => editor.refresh(), 1); 
            }
            
            function updateCurrentRequirementContent() {
                if (appState.currentReqIndex > -1) {
                    const content = editor.getValue();
                    appState.requirements[appState.currentReqIndex].content = content;
                    const firstLine = content.split('\n').find(l => l.trim() && !l.trim().startsWith('//')) || 'SIN TÍTULO';
                    const newTitle = firstLine.toUpperCase();
                    if (appState.requirements[appState.currentReqIndex].title !== newTitle) {
                       appState.requirements[appState.currentReqIndex].title = newTitle;
                       populateSelector();
                    }
                } else if (appState.currentReqIndex === -1) {
                    const fullContent = editor.getValue();
                    const reqContents = fullContent.split(/\n\n\/\/\s*----\s*FIN REQUISITO\s*----\s*\n\n/);

                    if (reqContents.length === appState.requirements.length) {
                        let titlesChanged = false;
                        appState.requirements.forEach((req, index) => {
                            const newContent = reqContents[index];
                            req.content = newContent;
                            const firstLine = newContent.split('\n').find(l => l.trim() && !l.trim().startsWith('//')) || 'SIN TÍTULO';
                            const newTitle = firstLine.toUpperCase();
                            if (req.title !== newTitle) {
                                req.title = newTitle;
                                titlesChanged = true;
                            }
                        });
                        if (titlesChanged) {
                            populateSelector();
                        }
                    } else {
                        console.warn("Discrepancia en el número de bloques de requisitos. El guardado desde la vista 'TODOS' se ha abortado para prevenir pérdida de datos. Asegúrate de que los separadores '// ---- FIN REQUISITO ----' son correctos.");
                    }
                }
            }

            // --- CORE LOGIC & PARSING ---
            const RULE_REGEX = /^(?:(.+?)\s*⇒)?\s*\[(!?[\w.]+)(?:\((.*)\))?(?:\{(@)?(.*)\})?\]\s*⇒\s*(.+)$/;

            function processAllRequirements() {
                updateCurrentRequirementContent();
                parseVocabulary();
                runDiagnostics();
            }
            
            function parseVocabulary() {
                Object.values(appState.vocabulary).forEach(set => set.clear());
                const fullText = appState.requirements.map(r => r.content).join('\n');
                const lines = fullText.split('\n').filter(line => !line.trim().startsWith('//'));
                let currentStateContext = null;

                for (const line of lines) {
                     if (line.endsWith(':')) {
                        currentStateContext = line.slice(0, -1).trim();
                        if(currentStateContext) appState.vocabulary.states.add(currentStateContext);
                    } else if (line.includes('⇒')) {
                        const match = line.match(RULE_REGEX);
                        if (match) {
                            const [, sourceFromLine, rawAction, eventText, isAtomic, guard, target] = match;
                            const source = (sourceFromLine || currentStateContext || '').trim();
                            if(source) appState.vocabulary.states.add(source);
                            if(target) appState.vocabulary.states.add(target.trim());

                            const actionParts = (rawAction.startsWith('!') ? rawAction.substring(1) : rawAction).split('.');
                            if(actionParts[0]) appState.vocabulary.actions.add(actionParts[0]);
                            if(actionParts[1]) appState.vocabulary.objects.add(actionParts[1]);

                            if(eventText){
                                const complexEventMatch = eventText.match(/^\(([^)]+)\)\.([\w.]+)$/);
                                if (complexEventMatch) {
                                    const [, sources, eventName] = complexEventMatch;
                                    sources.split(',').forEach(s => appState.vocabulary.sources.add(s.trim()));
                                    if(eventName) appState.vocabulary.events.add(eventName);
                                } else {
                                    eventText.split(',').forEach(e => { if(e) appState.vocabulary.events.add(e.trim()) });
                                }
                            }
                        }
                    }
                }
            }

            function getProjectDiagnostics() {
                const warnings = [];
                const allStates = new Set();
                const sourceStates = new Set();
                const stateTriggers = new Map();
                const problematicSourceStates = new Set();
                const fullText = appState.requirements.map(r => r.content).join('\n');
                const lines = fullText.split('\n').filter(line => !line.trim().startsWith('//'));
                let currentStateContext = null;

                 for (const line of lines) {
                    if (line.endsWith(':')) {
                        currentStateContext = line.slice(0, -1).trim();
                        if(currentStateContext) allStates.add(currentStateContext);
                    } else if (line.includes('⇒')) {
                        const match = line.match(RULE_REGEX);
                         if (match) {
                            const [, sourceFromLine, rawAction, eventText, isAtomic, guard, target] = match;
                            const source = (sourceFromLine || currentStateContext || '').trim();
                            const targetState = target.trim();
                            
                            if(source) { allStates.add(source); sourceStates.add(source); }
                            if(targetState) allStates.add(targetState);
                            
                            if (!rawAction.startsWith('!')) {
                                if (!stateTriggers.has(source)) stateTriggers.set(source, new Map());
                                const triggerKey = `${eventText || ''}|${guard || ''}`;
                                if (stateTriggers.get(source).has(triggerKey)) {
                                    warnings.push(`- Problema de determinismo: Múltiples reglas para '${source}' con el disparador '${eventText || 'ninguno'}'.`);
                                    problematicSourceStates.add(source);
                                } else {
                                    stateTriggers.get(source).set(triggerKey, true);
                                }
                            }
                        }
                    }
                }

                const orphanStates = [...allStates].filter(s => !sourceStates.has(s) && s !=='[*]');
                if (orphanStates.length > 0) {
                    warnings.push(`- Estados huérfanos detectados: ${orphanStates.join(', ')}.`);
                }
                
                return { warnings, problematicSourceStates };
            }
            
            function runDiagnostics() {
                const { warnings } = getProjectDiagnostics();
                diagnosticsOutput.innerHTML = warnings.length > 0 ? [...new Set(warnings)].join('<br>') : 'Todo en orden. No se encontraron problemas en el proyecto.';
                diagnosticsOutput.classList.toggle('text-yellow-700', warnings.length > 0);
            }

            function generateDependencyGraph() {
                const { requirements } = appState;
                if (requirements.length < 1) {
                    return 'graph TD;\n    A["No hay requisitos en el proyecto"];';
                }

                const reqData = requirements.map((req, index) => {
                    const id = `REQ${index}`;
                    const title = req.title.replace(/"/g, '#quot;');
                    const nonCommentLines = req.content.split('\n').filter(line => !line.trim().startsWith('//'));
                    const lines = nonCommentLines.filter(Boolean);
                    if(lines.length > 0) lines.shift();

                    const allStates = new Set();
                    const sourceStates = new Set();
                    let firstState = null;
                    let currentStateContext = null;

                    for (const line of lines) {
                        if (line.endsWith(':')) {
                            currentStateContext = line.slice(0, -1).trim();
                        } else if (line.includes('⇒')) {
                            const match = line.match(/^(?:(.+?)\s*⇒)?\s*\[(.*?)\]\s*⇒\s*(.+)$/);
                            if (match) {
                                const [, sourceFromLine, , target] = match;
                                const source = (sourceFromLine || currentStateContext || '').trim();
                                const targetState = target.trim();
                                if (source) {
                                    if (!firstState) firstState = source;
                                    allStates.add(source);
                                    allStates.add(targetState);
                                    sourceStates.add(source);
                                }
                            }
                        }
                    }
                    const finalStates = [...allStates].filter(s => !sourceStates.has(s));
                    return { id, title, initialStates: firstState ? [firstState] : [], finalStates };
                });

                const dependencies = new Set();
                for (let i = 0; i < reqData.length; i++) {
                    for (let j = 0; j < reqData.length; j++) {
                        if (i === j) continue;
                        const reqA = reqData[i]; // Potential provider
                        const reqB = reqData[j]; // Potential dependent
                        
                        const hasDependency = reqA.finalStates.some(finalState => reqB.initialStates.includes(finalState));
                        if (hasDependency) {
                            dependencies.add(`    ${reqB.id} -- depende --> ${reqA.id}`);
                        }
                    }
                }
                
                const graphDir = directionSelector.value || 'LR';
                let mermaidCode = `graph ${graphDir};\n\n`;
                reqData.forEach(req => {
                    mermaidCode += `    ${req.id}["${req.title}"];\n`;
                });
                
                if (dependencies.size > 0) {
                    mermaidCode += '\n' + [...dependencies].join('\n');
                }
                
                return mermaidCode;
            }


            function parseDslToMermaid(text) {
                const { problematicSourceStates } = getProjectDiagnostics();
                const nonCommentLines = text.split('\n').filter(line => !line.trim().startsWith('//'));
                const lines = nonCommentLines.filter(Boolean);
                if (lines.length < 1) return 'stateDiagram-v2';
                
                if (appState.currentReqIndex > -1 && lines.length > 0) {
                    lines.shift();
                }
                
                const graphDirection = directionSelector.value;
                const directionLine = graphDirection ? `direction ${graphDirection}\n` : '';
                let transitionsCode = '';
                const allStates = new Set();
                const sourceStates = new Set();
                const parsedRules = [];
                let currentStateContext = null;

                for (const line of lines) {
                     if (line.endsWith(':')) {
                        currentStateContext = line.slice(0, -1).trim();
                     } else if (line.includes('⇒')) {
                        const match = line.match(/^(?:(.+?)\s*⇒)?\s*\[(.*?)\]\s*⇒\s*(.+)$/);
                        if (match) {
                            const [, sourceFromLine, body, target] = match;
                            const source = (sourceFromLine || currentStateContext || '').trim();
                            if(source){
                                parsedRules.push({ source, target: target.trim(), ruleBody: body });
                                allStates.add(source); allStates.add(target.trim()); sourceStates.add(source);
                            }
                        }
                    }
                }

                let interruptCounter = 1;
                parsedRules.forEach(rule => {
                    const { source, target, ruleBody } = rule;
                    const ruleRegex = /^(!?[\w.]+)(?:\((.*)\))?(?:\{(@)?(.*)\})?$/;
                    const bodyParts = ruleBody.match(ruleRegex);
                    if (!bodyParts) return; 

                    const [, rawAction, eventText = '', isAtomic, guard = ''] = bodyParts;
                    const isInterrupt = rawAction.startsWith('!');
                    const action = isInterrupt ? rawAction.substring(1) : rawAction;
                    
                    const mermaidGuard = guard ? `[${isAtomic ? '⚛️ ' : ''}${guard}]` : '';
                    let mermaidAction = action ? `/ ${action}` : '';
                    if (isInterrupt) {
                        mermaidAction = action ? `/ p${interruptCounter}❗ ${action}` : `/ p${interruptCounter}❗`;
                        interruptCounter++;
                    }
                    
                    const labelParts = [eventText, mermaidGuard, mermaidAction].filter(Boolean);
                    let transitionLabel = labelParts.join(' ');
                    if (transitionLabel.includes(' ')) {
                         transitionLabel = `"${transitionLabel.replace(/"/g, '#quot;')}"`;
                    }
                    transitionsCode += `    ${source} --> ${target}: ${transitionLabel}\n`;
                });
                
                const finalStates = [...allStates].filter(s => !sourceStates.has(s));
                finalStates.forEach(state => { transitionsCode += `    ${state} --> [*]\n`; });
                
                const firstState = parsedRules.length > 0 ? parsedRules[0].source : null;
                let mermaidCode = `stateDiagram-v2\n${directionLine}\n`;
                if (firstState) {
                    mermaidCode += `    [*] --> ${firstState}\n\n`;
                }
                mermaidCode += transitionsCode;

                if (problematicSourceStates.size > 0) {
                    mermaidCode += '\n    %% -- Estilos de Error --\n';
                    mermaidCode += '    classDef estadoRojo fill:#f8d7da,stroke:#721c24,stroke-width:2px,color:black\n';
                    problematicSourceStates.forEach(state => {
                        mermaidCode += `    class ${state} estadoRojo\n`;
                    });
                }
                
                return mermaidCode;
            };
            
            let debounceTimer;
            const renderDiagram = async () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(async () => {
                    let mermaidCode;
                    if(diagramTypeSelector.value === 'dependency') {
                        mermaidCode = generateDependencyGraph();
                    } else {
                        mermaidCode = parseDslToMermaid(editor.getValue());
                    }

                    mermaidCodeOutput.textContent = mermaidCode;
                    try {
                        errorDisplay.classList.add('hidden');
                        const { svg } = await mermaid.render('mermaid-svg', mermaidCode);
                        mermaidOutput.innerHTML = svg;
                        if (externalWindow && !externalWindow.closed) {
                            const externalMermaidOutput = externalWindow.document.getElementById('mermaid-output');
                            if (externalMermaidOutput) externalMermaidOutput.innerHTML = svg;
                        }
                    } catch (error) {
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        [mermaidOutput, externalWindow?.document.getElementById('mermaid-output')].forEach(output => {
                            if(output) output.innerHTML = '';
                        });
                        errorDisplay.innerHTML = `<p class="font-bold">Error de sintaxis en Mermaid:</p><pre>${errorMessage.split('\n').slice(0, 5).join('\n')}</pre>`;
                        errorDisplay.classList.remove('hidden');
                    }
                }, 300);
            };
            
             // --- EXTERNAL WINDOW ---
            externalWindowBtn.addEventListener('click', () => {
                if (externalWindow && !externalWindow.closed) {
                    externalWindow.focus();
                    return;
                }
                externalWindow = window.open('', 'DiagramaMermaid', 'width=800,height=600,resizable=yes,scrollbars=no');
                if (externalWindow) {
                    externalWindow.document.write(`
                        <html>
                            <head><title>Diagrama en Vivo</title>
                            <style>
                                body { margin: 0; background-color: #f3f4f6; overflow: hidden; font-family: 'Inter', sans-serif; }
                                #pan-zoom-wrapper { width: 100vw; height: 100vh; cursor: grab; }
                                #pan-zoom-wrapper.grabbing { cursor: grabbing; }
                                #mermaid-output { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
                                #reset-button { position: fixed; top: 10px; right: 10px; z-index: 10; padding: 4px 10px; font-size: 12px; background: #fff; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
                            </style>
                            </head>
                            <body>
                                <button id="reset-button">Resetear Vista</button>
                                <div id="pan-zoom-wrapper"><div id="mermaid-output"></div></div>
                                <script>
                                    const viewport = document.body;
                                    const wrapper = document.getElementById('pan-zoom-wrapper');
                                    const resetButton = document.getElementById('reset-button');
                                    let scale = 1, isPanning = false, pointX = 0, pointY = 0, start = { x: 0, y: 0 };
                                    const setTransform = () => wrapper.style.transform = \`translate(\${pointX}px, \${pointY}px) scale(\${scale})\`;
                                    const resetView = () => { scale = 1; pointX = 0; pointY = 0; setTransform(); };
                                    viewport.onmousedown = (e) => { e.preventDefault(); isPanning = true; wrapper.classList.add('grabbing'); start = { x: e.clientX - pointX, y: e.clientY - pointY }; };
                                    viewport.onmouseup = () => { isPanning = false; wrapper.classList.remove('grabbing'); };
                                    viewport.onmouseleave = viewport.onmouseup;
                                    viewport.onmousemove = (e) => { if (!isPanning) return; e.preventDefault(); pointX = e.clientX - start.x; pointY = e.clientY - start.y; setTransform(); };
                                    viewport.onwheel = (e) => { e.preventDefault(); const newScale = Math.max(0.2, Math.min(5, scale * ((e.deltaY < 0) ? 1.1 : 0.9))); const rect = wrapper.getBoundingClientRect(); const xs = (e.clientX - rect.left - pointX) / scale; const ys = (e.clientY - rect.top - pointY) / scale; pointX -= xs * (newScale - scale); pointY -= ys * (newScale - scale); scale = newScale; setTransform(); };
                                    resetButton.onclick = resetView;
                                <\/script>
                            </body>
                        </html>
                    `);
                    externalWindow.document.close();
                    renderDiagram();
                }
            });
            window.addEventListener('beforeunload', () => {
                if (externalWindow && !externalWindow.closed) {
                    externalWindow.close();
                }
            });


            // --- EVENT LISTENERS ---
            editor.on('change', (cm, change) => {
                if (change.origin === 'setValue') {
                    processAllRequirements();
                    renderDiagram();
                    return;
                }
                
                const cursor = cm.getCursor();
                
                if (change.origin === '+input' && change.text[0] === '>' && cm.getLine(change.from.line)[change.from.ch - 1] === '-') {
                    const from = { line: change.from.line, ch: change.from.ch - 1 };
                    cm.replaceRange('⇒', from, {line: cursor.line, ch: cursor.ch}, '+internal');
                }
                
                renderDiagram();
                processAllRequirements();
            });

            editor.on('inputRead', (cm, change) => {
                 if (change.origin === '+input' && change.text[0].trim().length > 0 && !change.text[0].includes(' ')) {
                    cm.showHint({ hint: CodeMirror.hint.ldme, completeSingle: false });
                }
            });

            directionSelector.addEventListener('change', () => renderDiagram());
            diagramTypeSelector.addEventListener('change', () => renderDiagram());

            // Pan & Zoom, Resizer, Modal listeners
            showCodeBtn.addEventListener('click', () => { renderDiagram(); codeModal.classList.remove('hidden'); codeModal.classList.add('flex'); });
            closeModalBtn.addEventListener('click', () => { codeModal.classList.add('hidden'); codeModal.classList.remove('flex'); });
            codeModal.addEventListener('click', (e) => { if (e.target === codeModal) { codeModal.classList.add('hidden'); codeModal.classList.remove('flex'); } });
            const viewport = document.getElementById('diagram-viewport');
            const wrapper = document.getElementById('pan-zoom-wrapper');
            const resetButton = document.getElementById('reset-view');
            let scale = 1, isPanning = false, pointX = 0, pointY = 0, start = { x: 0, y: 0 };
            const setTransform = () => wrapper.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
            const resetView = () => { scale = 1; pointX = 0; pointY = 0; setTransform(); };
            viewport.onmousedown = (e) => { e.preventDefault(); isPanning = true; wrapper.classList.add('grabbing'); start = { x: e.clientX - pointX, y: e.clientY - pointY }; };
            viewport.onmouseup = () => { isPanning = false; wrapper.classList.remove('grabbing'); };
            viewport.onmouseleave = viewport.onmouseup;
            viewport.onmousemove = (e) => { if (!isPanning) return; e.preventDefault(); pointX = e.clientX - start.x; pointY = e.clientY - start.y; setTransform(); };
            viewport.onwheel = (e) => { e.preventDefault(); const newScale = Math.max(0.2, Math.min(5, scale * ((e.wheelDelta > 0) ? 1.1 : 0.9))); const rect = viewport.getBoundingClientRect(); const xs = (e.clientX - rect.left - pointX) / scale; const ys = (e.clientY - rect.top - pointY) / scale; pointX -= xs * (newScale - scale); pointY -= ys * (newScale - scale); scale = newScale; setTransform(); };
            resetButton.addEventListener('click', resetView);
            const resizer = document.getElementById('resizer');
            const leftPane = document.getElementById('left-pane');
            const rightPane = document.getElementById('right-pane');
            const mainContainer = document.getElementById('main-container');
            let isResizing = false;
            resizer.addEventListener('mousedown', (e) => { e.preventDefault(); isResizing = true; document.addEventListener('mousemove', handleMouseMove); document.addEventListener('mouseup', () => { isResizing = false; document.removeEventListener('mousemove', handleMouseMove); }); });
            const handleMouseMove = (e) => { if (!isResizing) return; const containerRect = mainContainer.getBoundingClientRect(); const newLeftWidth = e.clientX - containerRect.left; const newRightWidth = containerRect.width - newLeftWidth - resizer.offsetWidth; if (newLeftWidth > 100 && newRightWidth > 100) { leftPane.style.width = `${newLeftWidth}px`; rightPane.style.width = `${newRightWidth}px`; } };
        });
    </script>
</body>
</html>
