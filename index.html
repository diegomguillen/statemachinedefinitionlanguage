<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State Machine Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .grab { cursor: grab; }
        .grabbing { cursor: grabbing; }
        #mermaid-output svg { min-width: 100%; min-height: 100%; }
        
        .CodeMirror {
            height: 100%;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
        }
        .cm-s-default .cm-comment { color: #9ca3af; }
        .cm-s-default .cm-keyword { color: #8C4D4D; }
        .CodeMirror-hints {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            z-index: 20 !important;
        }

        #toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 8px;
            padding: 16px;
            position: fixed;
            z-index: 100;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.5s, visibility 0.5s;
        }
        #toast.show {
            visibility: visible;
            opacity: 1;
        }
        
        .color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
            background-color: #e0e0e0;
            border: 1px solid #c0c0c0;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 h-screen flex flex-col overflow-hidden">
    
    <div id="startup-modal" class="fixed inset-0 bg-gray-900 bg-opacity-60 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-2xl p-8 max-w-md w-full">
        <h2 class="text-2xl font-bold mb-6 text-center text-gray-700">State Machine Designer</h2>
        <div class="flex flex-col space-y-4">
            <button id="load-file-btn" class="flex items-center justify-center w-full px-4 py-3 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-100 transition-colors">
                <div class="p-2 rounded-full bg-gray-100 text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                    </svg>
                </div>
                <span class="ml-4 font-semibold text-gray-700">Load Existing Project</span>
            </button>
            <input type="file" id="file-input" class="hidden" accept=".json">
            
            <button id="new-project-btn" class="flex items-center justify-center w-full px-4 py-3 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-100 transition-colors">
                <div class="p-2 rounded-full bg-gray-100 text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
                    </svg>
                </div>
                <span class="ml-4 font-semibold text-gray-700">Create New Project</span>
            </button>
        </div>
    </div>
</div>

    <div id="app-container" class="h-full flex flex-col hidden">
    <header class="bg-white border-b border-gray-300 p-3 flex justify-between items-center shadow-sm">
    <div class="flex items-center space-x-4">
        <div id="req-dropdown" class="relative w-[600px]">
            <button id="req-dropdown-btn" class="text-xs bg-white border border-gray-300 rounded-md px-3 py-1 focus-outline-none focus:ring-1 focus:ring-blue-500 w-full text-left flex justify-between items-center transition-colors duration-300 disabled:bg-gray-100 disabled:cursor-not-allowed disabled:text-gray-400">
                <span>Seleccionar...</span>
                <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div id="req-dropdown-menu" class="hidden absolute mt-1 w-full bg-white border border-gray-300 rounded-md shadow-lg z-10">
                <div class="p-2 border-b">
                    <button id="select-all-btn" class="w-full text-left text-xs px-2 py-1 rounded hover:bg-gray-100">Seleccionar Todos</button>
                    <button id="clear-all-btn" class="w-full text-left text-xs px-2 py-1 rounded hover:bg-gray-100">Limpiar Selección</button>
                </div>
                <ul id="req-list" class="max-h-60 overflow-y-auto text-sm p-2"></ul>
            </div>
        </div>
        
        <button id="lock-btn" class="p-2 rounded-full hidden bg-red-100 text-red-600" title="Editor bloqueado. Haz clic para desbloquear.">
            <svg id="lock-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M10 2a3 3 0 00-3 3v1H6a2 2 0 00-2 2v7a2 2 0 002 2h8a2 2 0 002-2V8a2 2 0 00-2-2h-1V5a3 3 0 00-3-3zm-1 4V5a1 1 0 112 0v1H9z" clip-rule="evenodd" />
            </svg>
             <svg id="unlock-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" viewBox="0 0 20 20" fill="currentColor">
                <path d="M10 2a3 3 0 00-3 3v1H5a2 2 0 00-2 2v7a2 2 0 002 2h10a2 2 0 002-2V8a2 2 0 00-2-2h-1V5a3 3 0 00-3-3zm-1 4V5a1 1 0 112 0v1h-2z" />
                <path fill-rule="evenodd" d="M5 8H4a2 2 0 00-2 2v7a2 2 0 002 2h1.5V8z" clip-rule="evenodd" />
            </svg>
        </button>
        <button id="add-req-btn" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors" title="Añadir Nuevo Requisito">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg>
        </button>
    </div>
    
    <div>
        <h1 class="text-lg font-semibold text-gray-600 tracking-wide">State Machine Designer</h1>
    </div>

    <div class="flex items-center space-x-4">
        <select id="diagram-type-selector" class="text-xs bg-white border border-gray-300 rounded-md px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500">
            <option value="state">Diagrama de Estado</option>
            <option value="dependency">Dependencia de Requisitos</option>
        </select>
        <select id="graph-direction" class="text-xs bg-white border border-gray-300 rounded-md px-2 py-1 focus:outline-none focus:ring-1 focus:ring-blue-500">
            <option value="">Default</option>
            <option value="LR">Izquierda-Derecha</option>
            <option value="RL">Derecha-Izquierda</option>
            <option value="BT">Abajo-Arriba</option>
        </select>
        <button id="show-code-btn" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors" title="Ver Código Mermaid">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" /></svg>
        </button>
        <button id="reset-view" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors" title="Resetear Vista del Diagrama">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" /></svg>
        </button>
        <button id="external-window-btn" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors" title="Abrir Diagrama en Ventana Externa">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>
        </button>
        <div class="border-l border-gray-300 h-6"></div>
        <button id="help-btn" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors" title="Ayuda">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
        </button>
		<button id="show-events-btn" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors" title="Ver Vocabulario y Transiciones">
			<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
			<path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 10h16M4 14h16M4 18h16" />
			</svg>
		</button>
        <button id="load-json-btn" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors" title="Cargar archivo JSON">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
        </button>
        <button id="save-btn" class="p-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" title="Guardar Cambios">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5 3v18h14V8.5l-5.5-5.5H5z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M14 3v6h6" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 14h6v5H9v-5z" />
            </svg>
        </button>
    </div>
</header>
		<main id="main-container" class="flex flex-1 overflow-hidden">
            <div id="left-pane" class="w-1/3 p-4 flex flex-col" style="width: 70%;">
                
                <div class="flex-1 relative">
                    <div id="editor-wrapper" class="absolute inset-0"></div>
                </div>
                 <div class="mt-4 flex-shrink-0">
                    <h3 class="font-semibold text-gray-700 mb-2">Diagnóstico del Proyecto</h3>
                    <div id="diagnostics-output" class="bg-white border border-gray-300 rounded-lg p-3 text-xs h-24 overflow-y-auto"></div>
                </div>
            </div>

            <div id="resizer" class="w-2 cursor-col-resize bg-gray-300 hover:bg-blue-500 transition-colors"></div>

            <div id="right-pane" class="w-2/3 p-4 flex flex-col" style="width: 30%;">
                <div id="diagram-viewport" class="flex-1 bg-white border border-gray-300 rounded-lg overflow-hidden relative shadow-inner">
                    <div id="pan-zoom-wrapper" class="w-full h-full grab">
                        <div id="mermaid-output" class="w-full h-full flex items-center justify-center p-4"></div>
                    </div>
                     <div id="error-display" class="absolute top-0 left-0 w-full h-full bg-red-100 bg-opacity-90 text-red-700 p-4 font-mono text-sm hidden items-center justify-center overflow-auto"></div>
                </div>
            </div>
        </main>
    
    <div id="code-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-1/2 max-w-4xl flex flex-col max-h-[80vh]">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold">Código Mermaid Generado</h2>
                <button id="close-code-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl font-bold">&times;</button>
            </div>
            <div class="mb-4">
                <a id="mermaid-live-link" href="#" target="_blank" class="inline-flex items-center text-sm text-blue-600 hover:underline">
                    Abrir en Mermaid Live Editor
                    <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg>
                </a>
            </div>
            <pre class="bg-gray-100 text-gray-800 p-4 rounded-md overflow-auto flex-1 text-sm"><code id="mermaid-code-output"></code></pre>
        </div>
    </div>
	<div id="help-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-2xl p-6 max-w-2xl w-full flex flex-col max-h-[90vh]">
        <div class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-xl font-bold">Guía Rápida</h2>
            <button id="close-help-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl font-bold">&times;</button>
        </div>
        
        <div class="text-sm space-y-6 overflow-y-auto pr-2">
            <div>
                <h3 class="font-semibold text-lg mb-2">Definir Múltiples Estados Iniciales</h3>
                <p>Para que el diagrama comience desde varios puntos, añade un comentario especial al principio de tu requisito:</p>
                <pre class="bg-gray-100 p-2 rounded mt-1 text-xs"><code>// @initial: estado_A, estado_B</code></pre>
                <p class="mt-1">Esto creará flechas desde el nodo de inicio (`[*]`) hacia `estado_A` y `estado_B`.</p>
            </div>
            <div>
                <h3 class="font-semibold text-lg mb-2">Reglas de No Operación (`no.operacion`)</h3>
                <p>Para modelar un evento que es recibido pero no causa un cambio de estado, usa la acción `no.operacion`. El sistema lo visualizará automáticamente como un bucle.</p>
                <p class="mt-1">Si escribes:</p>
                <pre class="bg-gray-100 p-2 rounded mt-1 text-xs"><code>estado_actual ⇒ [no.operacion(evento_ignorado)] ⇒ no_cambia</code></pre>
                <p class="mt-1">El diagrama mostrará una flecha que sale de `estado_actual` y vuelve a entrar en él, etiquetada como `no.operacion`.</p>
            </div>

            <div>
                <h3 class="font-semibold text-xl mb-3 border-t pt-4">Diagnóstico del Proyecto</h3>
                <p class="text-xs text-gray-500 mb-4">La herramienta analiza continuamente los requisitos seleccionados para detectar los siguientes errores lógicos y de sintaxis:</p>
                <div class="space-y-4">
                    
                    <div>
                        <h4 class="font-semibold text-md mb-1">Errores de Sintaxis en Reglas</h4>
                        <p>Ocurre cuando una línea parece una regla (porque contiene `⇒`), pero no cumple con la estructura esperada, por ejemplo, por falta de corchetes o paréntesis. Esa línea no se renderizará.</p>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-xs"><code>// ADVERTENCIA: Falta un ']' al final del evento
A ⇒ [no.operacion((BT1).cambio) ⇒ B</code></pre>
                    </div>
                    <div>
                        <h4 class="font-semibold text-md mb-1">Problemas de Determinismo</h4>
                        <p>Ocurre cuando desde un mismo estado, el mismo evento o condición puede llevar a dos estados finales diferentes. Esto crea ambigüedad.</p>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-xs"><code>// ADVERTENCIA: 'evento' lleva a dos sitios desde 'A'
A ⇒ [accion(evento)] ⇒ B
A ⇒ [accion(evento)] ⇒ C</code></pre>
                    </div>
                    <div>
                        <h4 class="font-semibold text-md mb-1">Estados Huérfanos (Atrapamientos)</h4>
                        <p>Es un estado que no es final, pero del que no sale ninguna transición. Si el sistema llega aquí, se queda "atrapado" sin poder continuar.</p>
                         <pre class="bg-gray-100 p-2 rounded mt-1 text-xs"><code>// ADVERTENCIA: 'B' es un callejón sin salida
A ⇒ [evento1] ⇒ B
C ⇒ [evento2] ⇒ D</code></pre>
                    </div>
                    <div>
                        <h4 class="font-semibold text-md mb-1">Estados Inalcanzables</h4>
                        <p>Es un estado definido en las reglas al que es imposible llegar desde cualquier estado inicial. Representa "código muerto" en el diagrama.</p>
                         <pre class="bg-gray-100 p-2 rounded mt-1 text-xs"><code>// @initial: A
// ADVERTENCIA: Es imposible llegar a 'C'
A ⇒ [evento1] ⇒ B
C ⇒ [evento2] ⇒ D</code></pre>
                    </div>
                </div>
            </div>
            <div>
                <h3 class="font-semibold text-xl mb-3 border-t pt-4">Detección de Dependencias</h3>
                <p class="mb-4 text-xs text-gray-500">
                    La vista "Dependencia de Requisitos" genera un diagrama de alto nivel que muestra cómo se conectan lógicamente los diferentes requisitos entre sí.
                </p>

                <h4 class="font-semibold text-lg mb-2">¿Cómo funciona? 🧐</h4>
                <p>
                    La aplicación detecta una dependencia de un <strong>Requisito A</strong> hacia un <strong>Requisito B</strong> si se cumple una de estas dos condiciones:
                </p>
                <ul class="list-disc list-inside mt-2 space-y-2 pl-2">
                    <li>
                        Un <strong>estado final</strong> del Requisito A coincide con un <strong>estado inicial</strong> (definido con <code>// @initial:</code>) del Requisito B.
                    </li>
                    <li>
                       Un <strong>estado final</strong> del Requisito A coincide con cualquier <strong>estado de origen</strong> en el Requisito B (cualquier estado que esté a la izquierda de un <code>⇒</code>).
                    </li>
                </ul>

                <h4 class="font-semibold text-lg mt-4 mb-2">Sintaxis a tener en cuenta ✍️</h4>
                 <ul class="list-disc list-inside space-y-2 pl-2">
                    <li>
                       <strong>Estados Finales:</strong> Un estado se considera "final" dentro de un requisito si aparece a la derecha de un <code>⇒</code> pero nunca a la izquierda. ¡Asegúrate de que tus flujos terminan en estados bien definidos!
                    </li>
                    <li>
                       <strong>Puntos de Conexión:</strong> Para que la conexión sea detectada, el nombre del estado final en un requisito y el nombre del estado de origen/inicial en el otro deben ser <strong>exactamente iguales</strong>, incluyendo mayúsculas y minúsculas.
                    </li>
                </ul>
                 <pre class="bg-gray-100 p-2 rounded mt-4 text-xs"><code>// Requisito A
A ⇒ [evento] ⇒ Estado_Intermedio

// Requisito B
// @initial: Estado_Intermedio
Estado_Intermedio ⇒ [otro_evento] ⇒ C

// Resultado: Se dibujará una flecha desde "Requisito A" hacia "Requisito B".</code></pre>
            </div>
            
            <div>
                <h3 class="font-semibold text-xl mb-3 border-t pt-4">Uso como Herramienta de Diagrama de Flujo</h3>
                <p class="mb-4 text-xs text-gray-500">
                    Gracias a la lógica de bifurcaciones (`&lt;&lt;choice&gt;&gt;`), puedes usar el diseñador para modelar procesos y diagramas de flujo complejos. La clave es pensar en cómo cada símbolo del flujo se traduce a la sintaxis de reglas:
                </p>
            
                <ul class="list-disc list-inside space-y-2 pl-2 mb-4">
                    <li>
                       <strong>Proceso (Rectángulo):</strong> Se representa como una transición simple que lleva a un nuevo estado.
                       <pre class="bg-gray-100 p-1 rounded mt-1 text-xs w-fit"><code>Estado_A ⇒ [hacer.algo] ⇒ Estado_B</code></pre>
                    </li>
                    <li>
                       <strong>Decisión (Rombo):</strong> Se crea automáticamente cuando desde un mismo estado salen varias reglas con el mismo evento pero con <strong>guardias (`{...}`) diferentes</strong>.
                    </li>
                </ul>
            
                <h4 class="font-semibold text-lg mt-4 mb-2">Ejemplo: Flujo de Autenticación ✍️</h4>
                <p class="text-xs text-gray-500 mb-2">
                    El siguiente código modela un flujo de login donde el sistema reintenta la autenticación si falla y el número de intentos es menor a 10.
                </p>
                <pre class="bg-gray-100 p-2 rounded mt-1 text-xs"><code>// @initial: login
// El usuario introduce sus datos
login ⇒ [usuario.credenciales] ⇒ autenticar
// Se llama a la api
autenticar ⇒ [usuario.credenciales] ⇒ auth_service
// La api responde
auth_service ⇒[api.response] ⇒ autenticar
// Todo correcto
autenticar ⇒ [auth.response{ok}] ⇒ success
// Error, reintentar login
autenticar ⇒ [auth.response{error,intentos&lt;10}] ⇒ login
// Error grave
autenticar ⇒ [auth.response{error,intentos&gt;=10}] ⇒ expulsar_del_sistema</code></pre>
            </div>
            </div>
    </div>
</div>
	<div id="events-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 max-w-3xl w-full flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-xl font-bold">Vocabulario y Transiciones del Proyecto</h2>
                <button id="close-events-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl font-bold">&times;</button>
            </div>

            <div class="flex-1 overflow-y-auto pr-2 space-y-6">
                <div>
                    <h3 class="font-semibold text-lg mb-2">Tabla de Vocabulario</h3>
                    <table class="min-w-full divide-y divide-gray-200 border">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Tipo</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nombre</th>
                            </tr>
                        </thead>
                        <tbody id="events-table-body" class="bg-white divide-y divide-gray-200">
                            </tbody>
                    </table>
                </div>

                <div>
                    <h3 class="font-semibold text-lg mb-2">Tabla de Transiciones (Formato CSV)</h3>
                    <p class="text-xs text-gray-500 mb-2">Puedes seleccionar y copiar este bloque de texto para pegarlo en una hoja de cálculo.</p>
                    <pre id="transitions-csv-output" class="bg-gray-100 text-gray-800 p-4 rounded-md overflow-auto flex-1 text-sm whitespace-pre-wrap cursor-text"></pre>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/mode/simple.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- GLOBAL APP STATE ---
            let appState = { 
                requirements: [], 
                selectedReqIds: [],
                vocabulary: { states: new Set(), actions: new Set(), objects: new Set(), sources: new Set(), events: new Set() },
                isLocked: true // <-- AÑADIDO: Estado de bloqueo
            };
            let externalWindow = null;
						let shouldResetViewAfterRender = false;

            // --- DOM ELEMENTS ---
            const DOM = {
                startupModal: document.getElementById('startup-modal'),
                appContainer: document.getElementById('app-container'),
                editorWrapper: document.getElementById('editor-wrapper'),
                mermaidOutput: document.getElementById('mermaid-output'),
                errorDisplay: document.getElementById('error-display'),
                directionSelector: document.getElementById('graph-direction'),
                diagramTypeSelector: document.getElementById('diagram-type-selector'),
                diagnosticsOutput: document.getElementById('diagnostics-output'),
                codeModal: document.getElementById('code-modal'),
                helpModal: document.getElementById('help-modal'),
                showCodeBtn: document.getElementById('show-code-btn'),
                closeCodeModalBtn: document.getElementById('close-code-modal-btn'),
                closeHelpModalBtn: document.getElementById('close-help-modal-btn'),
                helpBtn: document.getElementById('help-btn'),
                mermaidCodeOutput: document.getElementById('mermaid-code-output'),
                addReqBtn: document.getElementById('add-req-btn'),
                externalWindowBtn: document.getElementById('external-window-btn'),
                reqDropdown: document.getElementById('req-dropdown'),
                reqDropdownBtn: document.getElementById('req-dropdown-btn'),
                reqDropdownMenu: document.getElementById('req-dropdown-menu'),
                reqList: document.getElementById('req-list'),
                selectAllBtn: document.getElementById('select-all-btn'),
                clearAllBtn: document.getElementById('clear-all-btn'),
                loadFileBtn: document.getElementById('load-file-btn'),
                fileInput: document.getElementById('file-input'),
                newProjectBtn: document.getElementById('new-project-btn'),
                saveBtn: document.getElementById('save-btn'),
                toast: document.getElementById('toast'),
				loadJsonBtn: document.getElementById('load-json-btn'),
				lockBtn: document.getElementById('lock-btn'),
                lockIcon: document.getElementById('lock-icon'),
                unlockIcon: document.getElementById('unlock-icon'),
				eventsModal: document.getElementById('events-modal'),
                closeEventsModalBtn: document.getElementById('close-events-modal-btn'),
                showEventsBtn: document.getElementById('show-events-btn'),
                eventsTableBody: document.getElementById('events-table-body'),
                transitionsCsvOutput: document.getElementById('transitions-csv-output')
            };
            
            // --- HELPERS ---
            const generateId = () => '_' + Math.random().toString(36).substring(2, 11);
            const showToast = (message) => { DOM.toast.textContent = message; DOM.toast.classList.add('show'); setTimeout(() => DOM.toast.classList.remove('show'), 3000); };
            const generatePastelColorPair = () => {
                const hue = (Date.now() % 3600 / 10 + Math.random() * 10) % 360 / 360;
                const saturation = 0.75;
                const lightnessFill = 0.90;
                const lightnessBorder = 0.60;
                const hslToHex = (h, s, l) => {
                    let r, g, b;
                    if (s === 0) { r = g = b = l; } 
                    else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1 / 6) return p + (q - p) * 6 * t;
                            if (t < 1 / 2) return q;
                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                            return p;
                        };
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1 / 3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1 / 3);
                    }
                    const toHex = x => { const hex = Math.round(x * 255).toString(16); return hex.length === 1 ? '0' + hex : hex; };
                    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                };
                return { fillColor: hslToHex(hue, saturation, lightnessFill), borderColor: hslToHex(hue, saturation, lightnessBorder) };
            };

            // --- CODEMIRROR SETUP ---
            CodeMirror.defineSimpleMode("ldme", { start: [ { regex: /\/\/.*/, token: "comment" }, { regex: /⇒|\[|\]|\(|\)|\{|\}|@|!|\.|\,/, token: "operator" }, { regex: /[\w-]+/, token: "keyword" } ] });
            const editor = CodeMirror(DOM.editorWrapper, { mode: 'ldme', lineNumbers: false, lineWrapping: true, extraKeys: {"Ctrl-Space": "autocomplete"} });
            
            CodeMirror.registerHelper('hint', 'ldme', (cm) => {
                const cursor = cm.getCursor();
                const token = cm.getTokenAt(cursor);
                const line = cm.getLine(cursor.line);
                let context = null;
                const lineBeforeCursor = line.substring(0, cursor.ch);

                if (lineBeforeCursor.lastIndexOf('[') > lineBeforeCursor.lastIndexOf(']')) {
                    if (lineBeforeCursor.lastIndexOf('.') > lineBeforeCursor.lastIndexOf('[')) context = 'objects';
                    else context = 'actions';
                } else if (lineBeforeCursor.lastIndexOf('(') > lineBeforeCursor.lastIndexOf(')')) {
                    const partInParen = lineBeforeCursor.substring(lineBeforeCursor.lastIndexOf('('));
                    if (partInParen.includes('.')) context = 'events';
                    else context = 'sources';
                } else {
                    context = 'states';
                }

                const start = token.start;
                const end = cursor.ch;
                const currentWord = token.string.trim();
                const list = [...appState.vocabulary[context]]
                    .filter(item => item.toLowerCase().startsWith(currentWord.toLowerCase()))
                    .map(item => ({ text: item, displayText: item }));

                if (list.length > 0 && currentWord.length > 0) {
                    return { list: list, from: CodeMirror.Pos(cursor.line, start), to: CodeMirror.Pos(cursor.line, end) };
                }
            });

            // --- FILE MANAGEMENT & STARTUP ---
            DOM.loadFileBtn.addEventListener('click', () => DOM.fileInput.click());
            DOM.fileInput.addEventListener('change', (event) => {
                shouldResetViewAfterRender = true; // <-- Activa la señal también al cargar un archivo
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            let data = JSON.parse(e.target.result);
                            if (Array.isArray(data) && data.every(r => 'title' in r && 'content' in r)) {
                                data = data.map(r => ({ ...r, id: r.id || generateId() }));
                                initializeProject(data);
                            } else { alert('Error: El archivo JSON no tiene el formato esperado.'); }
                        } catch (err) { alert('Error al leer el archivo JSON.'); }
                    };
                    reader.readAsText(file);
                }
            });
            DOM.newProjectBtn.addEventListener('click', () => {
                shouldResetViewAfterRender = true; // <-- Activa la señal para resetear la vista
                const { fillColor, borderColor } = generatePastelColorPair();
                const newReq = { 
                    id: generateId(), 
                    title: 'NUEVO REQUISITO', 
                    content: `// @color: ${fillColor}\n// @borde: ${borderColor}\n// @initial: estado_inicial\n\nestado_inicial ⇒ [accion.objeto(evento)] ⇒ estado_final` 
                };
                initializeProject([newReq]);
            });
			DOM.showEventsBtn.addEventListener('click', () => {
				populateEventsTable();
				DOM.eventsModal.classList.remove('hidden');
				DOM.eventsModal.classList.add('flex');
			});
			DOM.closeEventsModalBtn.addEventListener('click', () => {
				DOM.eventsModal.classList.add('hidden');
				DOM.eventsModal.classList.remove('flex');
			});
            DOM.saveBtn.addEventListener('click', () => {
                updateCurrentRequirementFromUI();
                const dataToSave = appState.requirements.map(({ id, title, content }) => ({ id, title, content }));
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToSave, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "requisitos.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
                showToast("✅ Fichero 'requisitos.json' listo para descargar.");

                // --- AÑADIDO ---
                // Vuelve a deshabilitar el botón después de guardar.
                DOM.saveBtn.disabled = true;
            });
						DOM.loadJsonBtn.addEventListener('click', () => {
                DOM.fileInput.click();
            });
            function initializeProject(requirementsData) {
                appState.requirements = requirementsData;
                appState.selectedReqIds = requirementsData.length > 0 ? [requirementsData[0].id] : [];
                DOM.startupModal.classList.add('hidden');
                DOM.appContainer.classList.remove('hidden');
                DOM.appContainer.classList.add('flex');
                populateSelector();
                loadRequirementInEditor();
                editor.refresh();
                
                // --- LÓGICA DE BLOQUEO AÑADIDA ---
                appState.isLocked = true; // Bloquea por defecto
                DOM.lockBtn.classList.remove('hidden'); // Muestra el botón de bloqueo
                updateLockState(); // Aplica el estado de bloqueo a toda la UI
            }
						function updateLockState() {
                const isLocked = appState.isLocked;

                // Cambia el icono y el estilo del botón de bloqueo
                DOM.lockIcon.classList.toggle('hidden', !isLocked);
                DOM.unlockIcon.classList.toggle('hidden', isLocked);
                DOM.lockBtn.classList.toggle('bg-red-100', isLocked);
                DOM.lockBtn.classList.toggle('text-red-600', isLocked);
                DOM.lockBtn.classList.toggle('bg-green-100', !isLocked);
                DOM.lockBtn.classList.toggle('text-green-600', !isLocked);
                DOM.lockBtn.title = isLocked ? 'Editor bloqueado. Haz clic para desbloquear.' : 'Editor desbloqueado. Haz clic para bloquear.';

                // Bloquea/desbloquea el editor de texto y el selector
                editor.setOption("readOnly", isLocked);
                DOM.reqDropdownBtn.disabled = isLocked;

                // Habilita/deshabilita el botón de añadir
                DOM.addReqBtn.disabled = isLocked;
                DOM.addReqBtn.classList.toggle('opacity-50', isLocked);
                DOM.addReqBtn.classList.toggle('cursor-not-allowed', isLocked);
                
                // Si se está bloqueando, deshabilita el botón de guardar
                if (isLocked) {
                    DOM.saveBtn.disabled = true;
                }
                
                // Llama a la nueva función para actualizar el estilo del botón Guardar
                updateSaveBtnStyle(); 
                
                // Habilita/deshabilita los botones de la lista
                const listButtons = DOM.reqList.querySelectorAll('.rename-btn, .delete-btn');
                listButtons.forEach(btn => {
                    btn.disabled = isLocked;
                    btn.classList.toggle('opacity-50', isLocked);
                });
            }
						function updateSaveBtnStyle() {
                const isDisabled = DOM.saveBtn.disabled;
                DOM.saveBtn.classList.toggle('opacity-50', isDisabled);
                DOM.saveBtn.classList.toggle('cursor-not-allowed', isDisabled);
            }

            // --- REQUIREMENT MANAGEMENT ---
            DOM.addReqBtn.addEventListener('click', () => {
								if (appState.isLocked) return;
                updateCurrentRequirementFromUI();
                const newTitle = prompt("Introduce el título para el nuevo requisito:", "Nuevo Requisito Sin Título");
                if (newTitle) {
                    const { fillColor, borderColor } = generatePastelColorPair();
                    const newReq = { 
                        id: generateId(), 
                        title: newTitle, 
                        content: `// @color: ${fillColor}\n// @borde: ${borderColor}\n// Define aquí las reglas.` 
                    };
                    appState.requirements.push(newReq);
                    appState.selectedReqIds = [newReq.id];
                    populateSelector();
                    loadRequirementInEditor();
                    editor.focus();
                }
            });
						DOM.lockBtn.addEventListener('click', () => {
                appState.isLocked = !appState.isLocked; // Invierte el estado
                updateLockState(); // Actualiza la UI
            });

            DOM.reqDropdownBtn.addEventListener('click', (e) => { e.stopPropagation(); DOM.reqDropdownMenu.classList.toggle('hidden'); });
            document.addEventListener('click', (e) => { if (!DOM.reqDropdown.contains(e.target)) DOM.reqDropdownMenu.classList.add('hidden'); });

            function getRequirementStyle(reqContent) {
                const style = { fillColor: null, borderColor: null };
                if (!reqContent) return null;
                const lines = reqContent.split('\n');
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('// @color:')) { style.fillColor = trimmedLine.split(':')[1].trim(); }
                    if (trimmedLine.startsWith('// @borde:')) { style.borderColor = trimmedLine.split(':')[1].trim(); }
                }
                return (style.fillColor || style.borderColor) ? style : null;
            }

            function populateSelector() {
                DOM.reqList.innerHTML = '';

                // --- INICIO DEL CAMBIO ---
                // Ordena una copia de los requisitos alfabéticamente por título.
                const sortedRequirements = [...appState.requirements].sort((a, b) => 
                    a.title.localeCompare(b.title, undefined, { numeric: true, sensitivity: 'base' })
                );
                // --- FIN DEL CAMBIO ---

                sortedRequirements.forEach(req => { // <-- Ahora itera sobre la lista ordenada
                    const li = document.createElement('li');
                    li.className = 'flex items-center justify-between p-1 hover:bg-gray-100 rounded';
                    const style = getRequirementStyle(req.content);
                    let indicatorStyle = '';
                    if (style) { indicatorStyle = `style="background-color:${style.fillColor || '#e0e0e0'}; border-color:${style.borderColor || '#c0c0c0'};"`; }

                    li.innerHTML = `<label class="flex-grow flex items-center space-x-2 cursor-pointer"><input type="checkbox" data-id="${req.id}" class="req-checkbox form-checkbox h-4 w-4 text-blue-600 rounded"><span class="color-indicator" ${indicatorStyle}></span><span class="truncate">${req.title}</span></label><div class="flex-shrink-0 space-x-1"><button title="Renombrar" data-id="${req.id}" class="rename-btn text-gray-400 hover:text-blue-600 p-1 rounded">✏️</button><button title="Eliminar" data-id="${req.id}" class="delete-btn text-gray-400 hover:text-red-600 p-1 rounded">🗑️</button></div>`;
                    DOM.reqList.appendChild(li);
                });
                updateDropdownState();
            }

            function updateDropdownState() {
                const checkboxes = DOM.reqList.querySelectorAll('.req-checkbox');
                checkboxes.forEach(cb => { cb.checked = appState.selectedReqIds.includes(cb.dataset.id); });
                const btnText = DOM.reqDropdownBtn.querySelector('span');
                if (appState.selectedReqIds.length === 0) { btnText.textContent = 'Ninguno seleccionado'; }
                else if (appState.selectedReqIds.length === 1) { const req = appState.requirements.find(r => r.id === appState.selectedReqIds[0]); btnText.textContent = req ? req.title : 'Error'; } 
                else { btnText.textContent = `Varios seleccionados (${appState.selectedReqIds.length})`; }
            }

            DOM.selectAllBtn.addEventListener('click', () => { appState.selectedReqIds = appState.requirements.map(r => r.id); updateDropdownState(); loadRequirementInEditor(); });
            DOM.clearAllBtn.addEventListener('click', () => { appState.selectedReqIds = []; updateDropdownState(); loadRequirementInEditor(); });
            
            DOM.reqList.addEventListener('click', (e) => {
								if (appState.isLocked) return;
                const target = e.target;
                const id = target.dataset.id || target.closest('[data-id]')?.dataset.id;
                if (!id) return;
                
                if (target.closest('.rename-btn')) {
                    updateCurrentRequirementFromUI();
                    const req = appState.requirements.find(r => r.id === id);
                    const newTitle = prompt(`Renombrar requisito:`, req.title);
                    if (newTitle && newTitle !== req.title) { req.title = newTitle; populateSelector(); loadRequirementInEditor(); }
                } else if (target.closest('.delete-btn')) {
                    updateCurrentRequirementFromUI();
                    const req = appState.requirements.find(r => r.id === id);
                    if (confirm(`¿Estás seguro de que quieres eliminar "${req.title}"?`)) {
                        appState.requirements = appState.requirements.filter(r => r.id !== id);
                        appState.selectedReqIds = appState.selectedReqIds.filter(selectedId => selectedId !== id);
                        if (appState.selectedReqIds.length === 0 && appState.requirements.length > 0) { appState.selectedReqIds = [appState.requirements[0].id]; }
                        populateSelector(); loadRequirementInEditor();
                    }
                } else if (target.type === 'checkbox') {
                    if (target.checked) { if (!appState.selectedReqIds.includes(id)) appState.selectedReqIds.push(id); } 
                    else { appState.selectedReqIds = appState.selectedReqIds.filter(i => i !== id); }
                    updateDropdownState(); loadRequirementInEditor();
                }
            });

            function loadRequirementInEditor() {
                let contentToShow = '', title = '';
                // Limpia los estilos del botón del selector
                DOM.reqDropdownBtn.style.backgroundColor = ''; 
                DOM.reqDropdownBtn.style.borderColor = ''; 
                DOM.reqDropdownBtn.style.borderWidth = '';

                if (appState.selectedReqIds.length === 0) {
                    contentToShow = '// No hay requisitos seleccionados.';
                    title = 'Ninguno seleccionado';
                } else if (appState.selectedReqIds.length === 1) {
                    const req = appState.requirements.find(r => r.id === appState.selectedReqIds[0]);
                    if (req) {
                        contentToShow = req.content;
                        title = req.title;
                        const style = getRequirementStyle(req.content);
                        // Aplica los estilos de color al botón del selector
                        if (style) {
                            DOM.reqDropdownBtn.style.backgroundColor = style.fillColor || '';
                            DOM.reqDropdownBtn.style.borderColor = style.borderColor || '#cccccc';
                            DOM.reqDropdownBtn.style.borderWidth = (style.borderColor || style.fillColor) ? '2px' : '';
                        }
                    } else {
                        appState.selectedReqIds = [];
                        return loadRequirementInEditor();
                    }
                } else {
                    const sortedReqs = appState.selectedReqIds.map(id => appState.requirements.find(r => r.id === id)).sort((a, b) => a.title.localeCompare(b.title));
                    contentToShow = sortedReqs.map(req => `// ---- REQUISITO: ${req.title} ----\n\n${req.content}`).join('\n\n');
                    title = 'Varios seleccionados';
                }

                // Actualiza el texto del botón del selector (el span interno)
                DOM.reqDropdownBtn.querySelector('span').textContent = title;
                editor.setValue(contentToShow);
                editor.setOption("readOnly", false);
                setTimeout(() => editor.refresh(), 1);
            }
						function findUnreachableStates(allRules, initialStates, allStates) {
                const reachableStates = new Set();
                const queue = [...initialStates];

                // Añade los puntos de partida a la lista de alcanzables
                initialStates.forEach(state => reachableStates.add(state));

                // Explora el grafo
                while (queue.length > 0) {
                    const currentState = queue.shift();
                    
                    // Busca todas las transiciones que salen del estado actual
                    const transitions = allRules.filter(rule => rule.source === currentState);
                    
                    for (const transition of transitions) {
                        const nextState = transition.target;
                        if (nextState && !reachableStates.has(nextState)) {
                            reachableStates.add(nextState);
                            queue.push(nextState);
                        }
                    }
                }
                
                // Compara todos los estados con los alcanzables y devuelve la diferencia
                const unreachable = new Set(
                    [...allStates].filter(state => !reachableStates.has(state) && state !== '[*]')
                );
                
                return unreachable;
            }
            
            function updateCurrentRequirementFromUI() {
                if (appState.selectedReqIds.length === 1) {
                    const req = appState.requirements.find(r => r.id === appState.selectedReqIds[0]);
                    if (req) {
                        const newContent = editor.getValue();
                        let needsRepopulate = false;
                        if (req.content !== newContent) {
                            const oldStyle = JSON.stringify(getRequirementStyle(req.content));
                            const newStyle = JSON.stringify(getRequirementStyle(newContent));
                            if(oldStyle !== newStyle) needsRepopulate = true;
                            req.content = newContent;
                        }
                        if (needsRepopulate) {
                            populateSelector();
                            // No es necesario llamar a loadRequirementInEditor aquí
                            // porque la acción del usuario no cambia el título.
                        }
                    }
                } else if (appState.selectedReqIds.length > 1) {
                    const fullContent = editor.getValue();
                    const reqSeparator = /^\/\/ ---- REQUISITO: (.*?) ----\s*/m;
                    const parts = fullContent.split(reqSeparator);
                    if (parts.length > 1) {
                        parts.shift();
                        for (let i = 0; i < parts.length; i += 2) {
                            const title = parts[i].trim();
                            const content = (parts[i+1] || '').trim();
                            const reqToUpdate = appState.requirements.find(r => r.title === title);
                            if (reqToUpdate) { reqToUpdate.content = content; }
                        }
                        populateSelector();
                    }
                }
            }
            // --- CORE LOGIC & PARSING ---
            const RULE_REGEX = /^(?:(.+?)\s*⇒)?\s*\[(!?[\w.]+)(?:\((.*)\))?(?:\{(@)?(.*)\})?\]\s*⇒\s*(.+)$/;

            function parseRequirementContent(content, respectInitialDirective = true) {
                if (!content) return { rules: [], allStates: new Set(), sourceStates: new Set(), initialStates: new Set(), finalStates: new Set(), malformedRules: [] };
                const lines = content.split('\n');
                const rulesLines = [];
                // --- AÑADIDO: 'malformedRules' para guardar los errores ---
                const parsed = { rules: [], allStates: new Set(), sourceStates: new Set(), initialStates: new Set(), finalStates: new Set(), malformedRules: [] };
                
                let explicitInitialStatesFound = false;
                for(const line of lines) {
                    const trimmedLine = line.trim();
                    if(respectInitialDirective && trimmedLine.startsWith('// @initial:')) {
                        const states = trimmedLine.split(':')[1].split(',').map(s => s.trim()).filter(Boolean);
                        states.forEach(s => parsed.initialStates.add(s));
                        explicitInitialStatesFound = true;
                    } else if(trimmedLine && !trimmedLine.startsWith('//')) {
                        rulesLines.push(line);
                    }
                }

                let currentStateContext = null;
                for (const line of rulesLines) {
                    if (line.endsWith(':')) { 
                        currentStateContext = line.slice(0, -1).trim(); 
                    } else if (line.includes('⇒')) {
                        const match = line.match(RULE_REGEX);
                        if (match) {
                            // ... (lógica de parseo correcta, sin cambios aquí)
                            const [, sourceFromLine, rawAction, eventText, isAtomic, guard, target] = match;
                            const source = (sourceFromLine || currentStateContext || '').trim();
                            const targetState = target.trim();
                            const rule = { source, target: targetState, rawAction, eventText: eventText || '', isAtomic: !!isAtomic, guard: guard || '' };
                            if (rawAction.startsWith('no.operacion')) { rule.target = source; rule.displayLabel = 'no.operacion'; }
                            if (source) {
                                if (parsed.rules.length === 0 && source !== '[*]' && !explicitInitialStatesFound) { parsed.initialStates.add(source); }
                                parsed.allStates.add(source); parsed.sourceStates.add(source);
                            }
                            if (rule.target) parsed.allStates.add(rule.target);
                            parsed.rules.push(rule);
                        } else {
                            // --- LÓGICA AÑADIDA: Si tiene flecha pero no encaja, es un error ---
                            parsed.malformedRules.push(line.trim());
                        }
                    }
                }
                parsed.finalStates = new Set([...parsed.allStates].filter(s => !parsed.sourceStates.has(s) && s !== '[*]'));
                return parsed;
            }

            function parseVocabulary() {
                const vocabulary = { states: new Set(), actions: new Set(), objects: new Set(), sources: new Set(), events: new Set() };
                appState.requirements.forEach(req => {
                    const { rules } = parseRequirementContent(req.content);
                    rules.forEach(rule => {
                        if (rule.source) vocabulary.states.add(rule.source);
                        if (rule.target) vocabulary.states.add(rule.target);
                        const actionParts = (rule.rawAction.startsWith('!') ? rule.rawAction.substring(1) : rule.rawAction).split('.');
                        if (actionParts[0]) vocabulary.actions.add(actionParts[0]);
                        if (actionParts[1]) vocabulary.objects.add(actionParts[1]);
                        if (rule.eventText) {
                            const complexEventMatch = rule.eventText.match(/^\(([^)]+)\)\.([\w.]+)$/);
                            if (complexEventMatch) {
                                const [, sources, eventName] = complexEventMatch;
                                sources.split(',').forEach(s => vocabulary.sources.add(s.trim()));
                                if (eventName) vocabulary.events.add(eventName);
                            } else {
                                rule.eventText.split(',').forEach(e => { if (e) vocabulary.events.add(e.trim()) });
                            }
                        }
                    });
                });
                appState.vocabulary = vocabulary;
            }

            function processAllRequirements() { 
                updateCurrentRequirementFromUI();
                parseVocabulary();
                runDiagnostics();
            }
            
            function runDiagnostics() {
                const { warnings } = getProjectDiagnostics();
                DOM.diagnosticsOutput.innerHTML = warnings.length > 0 ? warnings.join('<br>') : 'Todo en orden.';
                DOM.diagnosticsOutput.classList.toggle('text-yellow-700', warnings.length > 0);
            }

            function getProjectDiagnostics() {
                const warnings = new Set(); 
                const problematicSourceStates = new Set();
                const allStates = new Set(), sourceStates = new Set(), allRules = [], allInitialStates = new Set();
                
                const requirementsToScan = appState.selectedReqIds.length > 0 
                    ? appState.selectedReqIds.map(id => appState.requirements.find(r => r.id === id)) 
                    : appState.requirements;

                requirementsToScan.forEach(req => {
                    if(!req) return;
                    const parsed = parseRequirementContent(req.content);
                    parsed.allStates.forEach(s => allStates.add(s)); 
                    parsed.sourceStates.forEach(s => sourceStates.add(s));
                    parsed.initialStates.forEach(s => allInitialStates.add(s));
                    allRules.push(...parsed.rules);

                    // --- LÓGICA AÑADIDA: Comprueba y reporta las reglas malformadas ---
                    if (parsed.malformedRules.length > 0) {
                        parsed.malformedRules.forEach(badLine => {
                            warnings.add(`- Sintaxis inválida en '${req.title}': "${badLine}"`);
                        });
                    }
                });

                // Comprobación de estados inalcanzables
                const unreachableStates = findUnreachableStates(allRules, allInitialStates, allStates);
                if (unreachableStates.size > 0) {
                    warnings.add(`- Estados inalcanzables detectados: ${[...unreachableStates].join(', ')}.`);
                }
                
                // Comprobación de determinismo
                const stateTriggers = new Map();
                allRules.forEach(rule => {
                    if (!rule.rawAction.startsWith('!')) {
                        if (!stateTriggers.has(rule.source)) { stateTriggers.set(rule.source, new Map()); }
                        const sourceTriggers = stateTriggers.get(rule.source);
                        const triggerKey = `${rule.rawAction}|${rule.eventText || ''}|${rule.guard || ''}`;
                        if (sourceTriggers.has(triggerKey)) {
                            const previousTarget = sourceTriggers.get(triggerKey);
                            if (previousTarget !== rule.target) { 
                                warnings.add(`- Problema de determinismo para '${rule.source}' con el disparador '${rule.eventText || 'ninguno'}'.`); 
                                problematicSourceStates.add(rule.source); 
                            }
                        } else { 
                            sourceTriggers.set(triggerKey, rule.target); 
                        }
                    }
                });
                
                // Comprobación de estados huérfanos
                const orphanStates = [...allStates].filter(s => !sourceStates.has(s) && s !=='[*]');
                if (orphanStates.length > 0) { 
                    warnings.add(`- Estados huérfanos detectados: ${orphanStates.join(', ')}.`); 
                }
                
                return { warnings: [...warnings], problematicSourceStates };
            }

            function generateDependencyGraph() {
                const graphDirection = DOM.directionSelector.value;
                let mermaidCode = `graph ${graphDirection || 'TD'}\n`;
                let dependencyCode = '';
                const nodesInGraph = new Map(); // Para no dibujar nodos duplicados

                // Helper para parsear un requisito y guardarlo en el mapa del grafo
                const parseAndStoreNode = (req) => {
                    if (!nodesInGraph.has(req.id)) {
                        const parsed = parseRequirementContent(req.content);
                        const style = getRequirementStyle(req.content);
                        nodesInGraph.set(req.id, {
                            id: req.id,
                            title: (req.title || '').replace(/"/g, '#quot;'),
                            initialStates: parsed.initialStates,
                            finalStates: parsed.finalStates,
                            sourceStates: parsed.sourceStates,
                            style
                        });
                    }
                    return nodesInGraph.get(req.id);
                };
                
                // ---- LÓGICA DE DOS MODOS ----

                if (appState.selectedReqIds.length === 1) {
                    // MODO ENFOQUE: Un requisito seleccionado contra todos los demás
                    const selectedId = appState.selectedReqIds[0];
                    const selectedReq = appState.requirements.find(r => r.id === selectedId);
                    if (!selectedReq) return mermaidCode;

                    // 1. Añadir SOLO el nodo seleccionado al grafo para empezar.
                    const selectedReqData = parseAndStoreNode(selectedReq);
                    const allOtherReqs = appState.requirements.filter(r => r.id !== selectedId);

                    allOtherReqs.forEach(otherReq => {
                        // 2. Parsear los datos del otro requisito SIN añadirlo al grafo todavía.
                        const otherReqParsed = parseRequirementContent(otherReq.content);

                        // 3. Comprobar dependencias en ambas direcciones.
                        const hasOutgoingDep = [...selectedReqData.finalStates].some(finalState => otherReqParsed.initialStates.has(finalState) || otherReqParsed.sourceStates.has(finalState));
                        const hasIncomingDep = [...otherReqParsed.finalStates].some(finalState => selectedReqData.initialStates.has(finalState) || selectedReqData.sourceStates.has(finalState));
                        
                        // 4. Si se encuentra CUALQUIER dependencia, se añade el otro nodo al grafo y se dibuja la flecha.
                        if (hasOutgoingDep || hasIncomingDep) {
                            parseAndStoreNode(otherReq); // Ahora sí, añadimos el nodo conectado al mapa.
                            if (hasOutgoingDep) {
                                dependencyCode += `    ${selectedReqData.id} --> ${otherReq.id}\n`;
                            }
                            if (hasIncomingDep) {
                                dependencyCode += `    ${otherReq.id} --> ${selectedReqData.id}\n`;
                            }
                        }
                    });

                } else if (appState.selectedReqIds.length > 1) {
                    // MODO MÚLTIPLE: El comportamiento que ya tenías
                    const requirementsToDisplay = appState.selectedReqIds.map(id => appState.requirements.find(r => r.id === id)).filter(Boolean);
                    const reqData = requirementsToDisplay.map(req => parseAndStoreNode(req));

                    for (const reqA of reqData) {
                        for (const reqB of reqData) {
                            if (reqA.id === reqB.id) continue;
                            const hasDep = [...reqA.finalStates].some(finalState => reqB.initialStates.has(finalState) || reqB.sourceStates.has(finalState));
                            if (hasDep) {
                                dependencyCode += `    ${reqA.id} --> ${reqB.id}\n`;
                            }
                        }
                    }
                }
                
                // ---- GENERACIÓN FINAL DEL CÓDIGO MERMAID ----
                if (nodesInGraph.size === 0) return 'graph TD\n    subgraph No hay requisitos seleccionados\n    end';

                let nodeDefinitions = '';
                let styleDefinitions = '';
                const usedStyles = new Map();

                nodesInGraph.forEach((node, id) => {
                    nodeDefinitions += `    ${id}["${node.title}"]\n`;
                    if (node.style) {
                        const className = `style_${id}`;
                        if (!usedStyles.has(node.style.fillColor)) {
                            styleDefinitions += `    classDef ${className} fill:${node.style.fillColor},stroke:${node.style.borderColor},stroke-width:2px,color:#000\n`;
                            usedStyles.set(node.style.fillColor, className);
                        }
                        nodeDefinitions += `    class ${id} ${usedStyles.get(node.style.fillColor)}\n`;
                    }
                });

                return mermaidCode + styleDefinitions + nodeDefinitions + dependencyCode;
            }
            
            function parseDslToMermaid(text) {
    const respectInitial = appState.selectedReqIds.length === 1;
    const parsedInfo = parseRequirementContent(text, respectInitial);
    const { rules, initialStates, allStates, sourceStates } = parsedInfo;
    if (rules.length === 0) return 'stateDiagram-v2';
    const graphDirection = DOM.directionSelector.value;
    let mermaidCode = `stateDiagram-v2\n`;
    if(graphDirection) mermaidCode += `direction ${graphDirection}\n`;
    const stylesToApply = new Map();
    const allReqsInView = appState.selectedReqIds.length > 1 ? appState.selectedReqIds.map(id => appState.requirements.find(r => r.id === id)).filter(Boolean) : [appState.requirements.find(r => r.id === appState.selectedReqIds[0])];

    allReqsInView.forEach((req, index) => {
        if (!req) return;
        const style = getRequirementStyle(req.content);
        const className = `style${index}`;
        if(style) {
            stylesToApply.set(req.title, { style, className });
            mermaidCode += `    classDef ${className} fill:${style.fillColor},stroke:${style.borderColor},stroke-width:2px,color:#000\n`;
        }
    });
    
    // Helper para generar la etiqueta de una transición.
    const generateLabelForRule = (rule, options = { includeGuard: true }) => {
        if (rule.displayLabel) return rule.displayLabel;

        const { rawAction, eventText, isAtomic, guard } = rule;
        const isInterrupt = rawAction.startsWith('!');
        // CORRECCIÓN: Se ha arreglado el error de tipeo "raw-action" a "rawAction"
        const action = isInterrupt ? rawAction.substring(1) : rawAction;
        
        let mermaidGuard = '';
        if (options.includeGuard && guard) {
            mermaidGuard = `[${isAtomic ? '⚛️ ' : ''}${guard}]`;
        }

        let mermaidAction = action ? `/ ${action}` : '';
        if (isInterrupt) {
            mermaidAction = action ? `/ pX❗ ${action}` : `/ pX❗`;
        }

        const labelParts = [eventText, mermaidGuard, mermaidAction].filter(Boolean);
        let transitionLabel = labelParts.join(' ');
        if (transitionLabel.includes(' ') || transitionLabel.includes('"')) {
            transitionLabel = `"${transitionLabel.replace(/"/g, '#quot;')}"`;
        }
        return transitionLabel || '""';
    };
    
    // 1. Agrupar reglas por origen y evento (sin la guardia)
    const groupedRules = new Map();
    rules.forEach(rule => {
        const triggerKey = `${rule.rawAction}::${rule.eventText}`;
        const groupKey = `${rule.source}::${triggerKey}`;
        if (!groupedRules.has(groupKey)) {
            groupedRules.set(groupKey, []);
        }
        groupedRules.get(groupKey).push(rule);
    });

    let transitionsCode = '';
    let choiceCounter = 0;
    let interruptCounter = 1;
    const uniqueTransitions = new Set();

    // 2. Iterar sobre los grupos para generar el código
    for (const group of groupedRules.values()) {
        // Reasignar el contador de interrupción para las etiquetas que lo necesiten
        group.forEach(rule => {
            if (rule.rawAction.startsWith('!')) {
                const originalLabel = generateLabelForRule(rule);
                rule.displayLabel = originalLabel.replace(/pX❗/g, `p${interruptCounter++}❗`);
            }
        });
                                
        // Contar las guardias únicas dentro del grupo
        const uniqueGuards = new Set(group.map(rule => rule.guard || ''));

        if (group.length > 1 && uniqueGuards.size > 1) {
            // CASO 1: Bifurcación VÁLIDA (múltiples guardias distintas)
            const sourceState = group[0].source;
            const choiceId = `choice_${sourceState.replace(/[^a-zA-Z0-9]/g, '_')}_${choiceCounter++}`;
            
            mermaidCode += `    state ${choiceId} <<choice>>\n`;

            // Transición del origen al nodo 'choice' (sin guardia)
            const eventLabel = generateLabelForRule(group[0], { includeGuard: false });
            transitionsCode += `    ${sourceState} --> ${choiceId}: ${eventLabel}\n`;

            // Transiciones del 'choice' a cada destino (solo con su guardia)
            group.forEach(rule => {
                const guardLabel = rule.guard ? `"[${rule.isAtomic ? '⚛️ ' : ''}${rule.guard}]"` : '""';
                transitionsCode += `    ${choiceId} --> ${rule.target}: ${guardLabel}\n`;
            });
        } else {
            // CASO 2: Sin bifurcación (reglas únicas, duplicadas o errores de determinismo)
            // Se procesan individualmente, usando el Set para filtrar duplicados exactos.
            group.forEach(rule => {
                const transitionLabel = rule.displayLabel || generateLabelForRule(rule);
                const transitionKey = `${rule.source}::${rule.target}::${transitionLabel}`;

                if (!uniqueTransitions.has(transitionKey)) {
                    uniqueTransitions.add(transitionKey);
                    transitionsCode += `    ${rule.source} --> ${rule.target}: ${transitionLabel}\n`;
                }
            });
        }
        
        // --- CÓDIGO REDUNDANTE ELIMINADO ---
        // El bloque "if (group.length === 1) { ... } else if { ... }" que estaba aquí ha sido eliminado.
    }
    
    const finalStates = [...allStates].filter(s => !sourceStates.has(s) && s !=='[*]');
    finalStates.forEach(state => { transitionsCode += `    ${state} --> [*]\n`; });
    initialStates.forEach(state => { mermaidCode += `    [*] --> ${state}\n`; });
    mermaidCode += '\n' + transitionsCode;

    const stateToTitleMap = new Map();
    allReqsInView.forEach(req => { 
        if(!req) return;
        parseRequirementContent(req.content, false).allStates.forEach(state => stateToTitleMap.set(state, req.title)); 
    });
    
    let classApplications = '';
    allStates.forEach(state => {
        if (state === '[*]') return;
        const title = stateToTitleMap.get(state);
        const styleInfo = stylesToApply.get(title);
        if (styleInfo) { classApplications += `    class ${state} ${styleInfo.className}\n`; }
    });

    if(classApplications) mermaidCode += '\n' + classApplications;
    const { problematicSourceStates } = getProjectDiagnostics();
    if (problematicSourceStates.size > 0) {
        mermaidCode += '\n    classDef estadoRojo fill:#f8d7da,stroke:#721c24,stroke-width:2px,color:black\n';
        problematicSourceStates.forEach(state => { mermaidCode += `    class ${state} estadoRojo\n`; });
    }
    return mermaidCode;
};
						
			function populateEventsTable() {
                // --- 1. POBLAR TABLA DE VOCABULARIO (CON NUEVOS CAMPOS) ---
                parseVocabulary(); // Asegura que el vocabulario base está cargado
                const tableBody = DOM.eventsTableBody;
                tableBody.innerHTML = '';

                // Obtener todas las reglas de los requisitos seleccionados
                const contentOfSelectedReqs = editor.getValue();
                const { rules } = parseRequirementContent(contentOfSelectedReqs, false); // <-- AQUÍ ESTABA EL ERROR (ahora corregido)

                const addRow = (type, name) => {
                    const row = document.createElement('tr');
                    const typeClass =
                        type === 'Estado' ? 'text-blue-600 font-semibold' :
                        type === 'Comando' ? 'text-purple-600' :
                        type === 'Disparador' ? 'text-red-600' :
                        type === 'Acción' ? 'text-green-600' :
                        type === 'Objeto' ? 'text-indigo-600' :
                        'text-gray-900';
                    row.innerHTML = `<td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${typeClass}">${type}</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 font-mono">${name}</td>`;
                    tableBody.appendChild(row);
                };

                // Añadir nuevos tipos de datos (Comandos y Disparadores)
                const uniqueCommands = new Set(rules.filter(r => r.action && r.object).map(r => `${r.action}.${r.object}`));
                const uniqueTriggers = new Set(rules.filter(r => r.eventText).map(r => r.eventText));

                [...uniqueCommands].sort().forEach(name => addRow('Comando', name));
                [...uniqueTriggers].sort().forEach(name => addRow('Disparador', name));

                // Añadir el resto del vocabulario
                [...appState.vocabulary.states].sort().forEach(name => addRow('Estado', name));
                [...appState.vocabulary.actions].sort().forEach(name => addRow('Acción', name));
                [...appState.vocabulary.objects].sort().forEach(name => addRow('Objeto', name));
                [...appState.vocabulary.sources].sort().forEach(name => addRow('Fuente', name));

                // --- 2. POBLAR TABLA DE TRANSICIONES CSV (SIN GUARDAS) ---
                const csvOutput = DOM.transitionsCsvOutput;
                const uniqueTransitions = new Set();

                uniqueTransitions.add("Estado Origen;Disparador;Estado Destino"); // Cabecera del CSV

                rules.forEach(rule => {
                    // Construir la parte del "disparador" SIN la guarda {...}
                    let trigger = rule.eventText || '';

                    // Si el disparador está vacío, usar la acción como referencia
                    if (!trigger && rule.rawAction) {
                        trigger = `[${rule.rawAction}]`;
                    }

                    const transitionKey = `${rule.source};${trigger || 'N/A'};${rule.target}`;
                    uniqueTransitions.add(transitionKey);
                });

                csvOutput.textContent = [...uniqueTransitions].join('\n');
            }
            
            let debounceTimer;
            // Add a new flag here
      

            const renderDiagram = async () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(async () => {
                    updateCurrentRequirementFromUI();
                    processAllRequirements();
                    let mermaidCode;
                    if(DOM.diagramTypeSelector.value === 'dependency') { mermaidCode = generateDependencyGraph(); }
                    else { mermaidCode = parseDslToMermaid(editor.getValue()); }
                    DOM.mermaidCodeOutput.textContent = mermaidCode;

                    // ... (la lógica del enlace a Mermaid Live)

                    try {
                        DOM.errorDisplay.classList.add('hidden');
                        const { svg } = await mermaid.render('mermaid-svg', mermaidCode);
                        DOM.mermaidOutput.innerHTML = svg;

                        // --- LÓGICA DE RESETEO CORREGIDA ---
                        // Si la señal de reseteo está activa, ejecuta el reseteo y apaga la señal.
                        if (shouldResetViewAfterRender) {
                            resetView();
                            shouldResetViewAfterRender = false;
                        }

                        if (externalWindow && !externalWindow.closed) {
                            const externalMermaidOutput = externalWindow.document.getElementById('mermaid-output');
                            if (externalMermaidOutput) externalMermaidOutput.innerHTML = svg;
                        }
                    } catch (error) {
                        // ... (tu manejo de errores)
                    }
                }, 300);
            };
            
            // --- EVENT LISTENERS ---
            editor.on('change', (cm, change) => {
                if (change.origin !== 'setValue' && !appState.isLocked) {
                    DOM.saveBtn.disabled = false;
                    updateSaveBtnStyle(); // <-- AÑADE ESTA LÍNEA
                }
                
                if (change.origin === 'setValue') {
                    renderDiagram();
                    return;
                }
                
                const cursor = cm.getCursor();
                if (change.origin === '+input' && change.text[0] === '>' && cm.getLine(change.from.line)[change.from.ch - 1] === '-') {
                    const from = { line: change.from.line, ch: change.from.ch - 1 };
                    cm.replaceRange('⇒', from, {line: cursor.line, ch: cursor.ch}, '+internal');
                }

                renderDiagram();
            });
            editor.on('inputRead', (cm, change) => {
                if (change.origin === '+input' && change.text[0].trim().length > 0 && !change.text[0].includes(' ')) {
                    cm.showHint({ hint: CodeMirror.hint.ldme, completeSingle: false });
                }
            });
            
            DOM.directionSelector.addEventListener('change', renderDiagram);
            DOM.diagramTypeSelector.addEventListener('change', renderDiagram);

            // --- UI Listeners (Modals, Pan & Zoom, etc.) ---
            DOM.helpBtn.addEventListener('click', () => { DOM.helpModal.classList.remove('hidden'); DOM.helpModal.classList.add('flex'); });
            DOM.closeHelpModalBtn.addEventListener('click', () => { DOM.helpModal.classList.add('hidden'); DOM.helpModal.classList.remove('flex'); });
            DOM.showCodeBtn.addEventListener('click', () => { renderDiagram(); DOM.codeModal.classList.remove('hidden'); DOM.codeModal.classList.add('flex'); });
            DOM.closeCodeModalBtn.addEventListener('click', () => { DOM.codeModal.classList.add('hidden'); DOM.codeModal.classList.remove('flex'); });
            DOM.externalWindowBtn.addEventListener('click', () => {
                if (externalWindow && !externalWindow.closed) { externalWindow.focus(); return; }
                externalWindow = window.open('', 'DiagramaMermaid', 'width=800,height=600,resizable=yes,scrollbars=no');
                if (externalWindow) {
                    externalWindow.document.write(`<html><head><title>Diagrama en Vivo</title><style>body{margin:0;background-color:#f3f4f6;overflow:hidden;font-family:'Inter',sans-serif}#pan-zoom-wrapper{width:100vw;height:100vh;cursor:grab}#pan-zoom-wrapper.grabbing{cursor:grabbing}#mermaid-output{width:100%;height:100%;display:flex;align-items:center;justify-content:center}#reset-button{position:fixed;top:10px;right:10px;z-index:10;padding:4px 10px;font-size:12px;background:#fff;border:1px solid #d1d5db;border-radius:6px;cursor:pointer;box-shadow:0 1px 2px rgba(0,0,0,.05)}</style></head><body><button id="reset-button">Resetear Vista</button><div id="pan-zoom-wrapper"><div id="mermaid-output"></div></div><script>const v=document.body,w=document.getElementById('pan-zoom-wrapper'),r=document.getElementById('reset-button');let s=1,p=!1,x=0,y=0,t={x:0,y:0};const z=()=>w.style.transform=\`translate(\${x}px, \${y}px) scale(\${s})\`,R=()=>{s=1;x=0,y=0;z()};v.onmousedown=e=>{e.preventDefault();p=!0;w.classList.add('grabbing');t={x:e.clientX-x,y:e.clientY-y}};v.onmouseup=()=>{p=!1;w.classList.remove('grabbing')};v.onmouseleave=v.onmouseup;v.onmousemove=e=>{if(!p)return;e.preventDefault();x=e.clientX-t.x;y=e.clientY-t.y;z()};v.onwheel=e=>{e.preventDefault();const n=Math.max(.2,Math.min(5,s*(e.deltaY<0?1.1:.9))),c=w.getBoundingClientRect(),o=(e.clientX-c.left-x)/s,a=(e.clientY-c.top-y)/s;x-=o*(n-s);y-=a*(n-s);s=n;z()};r.onclick=R;<\/script></body></html>`);
                    externalWindow.document.close();
                    renderDiagram(); 
                }
            });
            window.addEventListener('beforeunload', () => { if (externalWindow && !externalWindow.closed) externalWindow.close(); });
            
            const closeableModals = [DOM.helpModal, DOM.codeModal];
            closeableModals.forEach(modal => { modal.addEventListener('click', (e) => { if (e.target === modal) { modal.classList.add('hidden'); modal.classList.remove('flex'); } }); });
            
            const viewport = document.getElementById('diagram-viewport'), wrapper = document.getElementById('pan-zoom-wrapper'), resetButton = document.getElementById('reset-view');let scale=1, isPanning=false, pointX=0, pointY=0, start={x:0,y:0};const setTransform=()=>{wrapper.style.transform=`translate(${pointX}px,${pointY}px) scale(${scale})`};const resetView=()=>{scale=1;pointX=0;pointY=0;setTransform()};viewport.onmousedown=(e)=>{e.preventDefault();isPanning=true;wrapper.classList.add('grabbing');start={x:e.clientX-pointX,y:e.clientY-pointY}};viewport.onmouseup=()=>{isPanning=false;wrapper.classList.remove('grabbing')};viewport.onmouseleave=viewport.onmouseup;viewport.onmousemove=(e)=>{if(!isPanning)return;e.preventDefault();pointX=e.clientX-start.x;pointY=e.clientY-start.y;setTransform()};viewport.onwheel=(e)=>{e.preventDefault();const newScale=Math.max(.2,Math.min(5,scale*((e.deltaY<0)?1.1:.9)));const rect=viewport.getBoundingClientRect();const xs=(e.clientX-rect.left-pointX)/scale,ys=(e.clientY-rect.top-pointY)/scale;pointX-=xs*(newScale-scale);pointY-=ys*(newScale-scale);scale=newScale;setTransform()};resetButton.addEventListener('click',resetView);const resizer=document.getElementById('resizer'),leftPane=document.getElementById('left-pane'),rightPane=document.getElementById('right-pane'),mainContainer=document.getElementById('main-container');let isResizing=false;resizer.addEventListener('mousedown',(e)=>{e.preventDefault();isResizing=true;document.addEventListener('mousemove',handleMouseMove);document.addEventListener('mouseup',()=>{isResizing=false;document.removeEventListener('mousemove',handleMouseMove)})});const handleMouseMove=(e)=>{if(!isResizing)return;const containerRect=mainContainer.getBoundingClientRect(),newLeftWidth=e.clientX-containerRect.left,newRightWidth=containerRect.width-newLeftWidth-resizer.offsetWidth;if(newLeftWidth>100&&newRightWidth>100){leftPane.style.width=`${newLeftWidth}px`;rightPane.style.width=`${newRightWidth}px`}};
        });
    </script>
</body>
</html>